{"name":"Groovy-discriminatedunion","tagline":"A Groovy discriminated union implementation","body":"Discriminated Unions\r\n====================\r\nDiscriminated unions provide support for values that can be one of a number of named cases, possibly each with different values and types. UsesDiscriminated unions are useful for heterogeneous data: \r\n\r\n* Data that can have special cases, including valid and error cases\r\n* Data that varies in type from one instance to another\r\n* As an alternative for small object hierarchies. \r\n\r\nSee: [MSDN][DU-msdn],[Wikipedia][DU-wikipedia]. \r\n\r\n\r\n##A Groovy Discriminated Union\r\n### `Option` Type\r\nLet's say we want a variable `option` to hold some value (`Some`) or no value (`None`). Let's start with `Some`:\r\n\r\n```groovy\r\ndef option = Option.Some( 100 )\r\n```\r\nWe can test for `Some` vs. `None` like this:\r\n\r\n```groovy\r\noption.match {\r\n  when Some then { println \"We have 'some' value\" }\r\n  when Some then { println \"It's None!\" }\r\n}\r\n```\r\n\r\nWe can get the value of an `Option` like this:\r\n\r\n```groovy\r\ndef value = option.match {\r\n  when Some then { it }\r\n  otherwise null\r\n}\r\nassert 100 == value\r\n```\r\n\r\nwhere `otherwise` is a *catch-all* matcher. When an Option is matched with Some, the value held by Some is injected into the `then` closure (if a closure is provided).\r\n\r\nIt follows that:\r\n\r\n```groovy\r\nassert Option.None().match{\r\n  when Some then false\r\n  when None then true\r\n  otherwise false\r\n}\r\n```\r\n\r\n##About the `match` method\r\n* A `match` method is defined for `DiscriminatedUnion` and is available to its descendants (e.g. Option). \r\n* We also inject a `match` method into `List` for list based pattern matching.\r\n* `match` matches one and only one `when` pattern or `othewise` if no matching `when` was found.\r\n* `match` returns the result of the matched pattern, i.e. the argument to `then`. If a closure is supplied, arguments are injected into the closure depending on the matched pattern, the closure is evaluated and its result returned. In the case of a non-closure argument, the argument is returned.  *Note* that any non-closure expression in the entire `match` block is evaluated even if it is part of a pattern that has not matched. When in doubt, enclose `then` arguments in a closure, or expect interesting side-effects.\r\n* `match` delegates the actual matching to handlers based primarily on its context (e.g. Option vs List). So in the case of `Option.match`, the underlying matcher matches `Class`. Other matchers match against value, vector size, etc. A special case is if a closure is supplied as the match pattern, e.g.:\r\n \r\n```groovy\r\nsomething.match {\r\n  when { it == 'abc' } then { ... }\r\n}\r\n```\r\nIn this case, the closure is evaluated with a single argument such that `it == something`\r\n\r\n##List Patterns and `match`\r\n### `Cons` and `Nil`\r\nThe `Cons` pattern matches lists and provides `then` with the head element and tail list. Likewise, `Nil` matches against an empty list.\r\n\r\n```groovy\r\nassert [ 1, 2, 3 ].match {\r\n  when Cons then { h, t -> h == 1 && t == [ 2, 3 ] }\r\n  when Nil then false\r\n  otherwise false\r\n}\r\n```\r\nAs in F#, this pattern lends itself to tail recursion:\r\n\r\n```groovy\r\ndef sumList( List l ) {\r\n  l.match {\r\n    when Cons then { h, List t -> h + sumList( t ) }\r\n    when Nil then 0\r\n  }\r\n}\r\n\r\nassert 15 == sumList( [ 1, 2, 3, 4, 5 ] )\r\n```\r\n\r\n###List Equality\r\nList equality is straightforward:\r\n\r\n```groovy\r\nassert [ true, false ].match {\r\n  when( [ false, false ] ) then false\r\n  when( [ false, true ] ) then false\r\n  when( [ true, false ] ) then true\r\n  when( [ true, true ] ) then false\r\n  otherwise false\r\n}\r\n```\r\n\r\nObviously the contents of the list isn't limited to booleans as in the example above. We note that truth-table style matching is a compact alternative to if-then-else/switch statements. \r\n\r\n###Matching with wildcards\r\nWhen matching lists, we can replace a list element with the wildcard operator `_` (underscore) to imply that we'll accept anything at that position in the list.\r\n\r\n```groovy\r\nassert [ 1, 2, 3, \"a\" ].match {\r\n  when( [ 1, 2, 3, 4 ] ) then false\r\n  when( [ 1, 2, 3, _ ] ) then true\r\n  otherwise false\r\n}\r\n```\r\n\r\n###Matching with Variables\r\nWe can replace the wildcard operator with a variable identifier (underfined, standard scoping rules apply) to imply that we'll matching anything, but want to capture the matched value.\r\n\r\n```groovy\r\nassertEquals 1, [ 1, 2, 3, \"a\" ].match {\r\n  when( [ x, 2, 3, _ ] ) then { x }\r\n  otherwise 100\r\n}\r\n```\r\n\r\n\r\n##Custom DU Types - Trees\r\nWe can define custom DU types, e.g. a Tree node with a value and two child nodes each of which can be a Tree node or a Tip (terminal node, no value) like this (see sources - tests):\r\n\r\n```groovy\r\nclass Tree extends DiscriminatedUnion {\r\n  /**\r\n   * Types held by this DU\r\n   */\r\n  List types = [ Tip, Tree ]\r\n\r\n  int val\r\n  Tree leftChild\r\n  Tree rightChild\r\n\r\n  protected Tree( ) {\r\n    this( 0, null, null )\r\n  }\r\n  \r\n  Tree( int v ) {\r\n    this( v, new Tip(), new Tip() )\r\n  }\r\n\r\n  Tree( int v, Tree l ) {\r\n    this( v, l, new Tip() )\r\n  }\r\n\r\n  Tree( int v, Tree l, Tree r ) {\r\n    val = v\r\n    leftChild = l\r\n    rightChild = r\r\n    useSelfAsValue = true\r\n  }\r\n\r\n  String toString( ) {\r\n    \"Tree[$val, $leftChild, $rightChild]\"\r\n  }\r\n}\r\n\r\n```\r\n\r\nand a Tip node:\r\n\r\n```groovy\r\nclass Tip extends Tree {\r\n  Tip( ) {}\r\n\r\n  String toString( ) {\r\n    \"Tip\"\r\n  }\r\n}\r\n```\r\n\r\nWe can do a recursive walk on the tree:\r\n\r\n```groovy\r\ndef sumTree( Tree t ) {\r\n  t?.match {\r\n    when Tip then 0\r\n    when Tree then { Tree n -> n.val + sumTree( n.leftChild ) + sumTree( n.rightChild ) }\r\n  }\r\n}\r\n\r\ndef tree = new Tree( 0, new Tree( 1, new Tree( 2 ) ), new Tree( 3, new Tree( 4 ) ) )\r\nassertEquals 10, sumTree( tree )\r\n```\r\n\r\n\r\n##Credits\r\nThe core matcher functionality comes from [graphology][graphology].\r\n\r\n[graphology]: https://github.com/will-lp/graphology-case-match\r\n[DU-msdn]:http://msdn.microsoft.com/en-us/library/dd233226.aspx\r\n[DU-wikipedia]:https://en.wikipedia.org/wiki/Tagged_union\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}